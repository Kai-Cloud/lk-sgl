<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>数字华容道</title>
  <link rel="stylesheet" href="style.css">
  <link rel="manifest" href="manifest.json">
</head>
<body>

  <div class="page-wrapper">

    <!-- Top Bar -->
    <div class="top-bar">
      <button class="back-btn" id="backBtn">&#9664; 返回大厅</button>
      <h1>数字华容道</h1>
      <span></span>
    </div>

    <!-- Level Select -->
    <div id="levelSelect">
      <div class="level-grid" id="levelGrid"></div>
    </div>

    <!-- Game Area -->
    <div class="game-area" id="gameArea">
      <div class="info-bar">
        <span id="levelLabel">关卡 1</span>
        <span>步数: <b id="moveCount">0</b> / 推荐 <b id="parCount">0</b></span>
      </div>
      <div class="board-container" id="boardContainer"></div>
      <div class="btn-row">
        <button class="btn btn-reset" id="resetBtn">重置</button>
        <button class="btn btn-primary" id="levelListBtn">选关</button>
      </div>
    </div>

  </div>

  <!-- Win Overlay -->
  <div class="overlay" id="winOverlay">
    <div class="win-card">
      <h2>恭喜过关！</h2>
      <div class="win-stars" id="winStars"></div>
      <p id="winMsg"></p>
      <div>
        <button class="btn btn-reset" id="winBackBtn">选关</button>
        <button class="btn btn-primary" id="winNextBtn">下一关</button>
      </div>
    </div>
  </div>

  <script>
    /* =====================================================
       STORAGE ADAPTER FOR LK-SCL INTEGRATION
       Dual-mode storage: localStorage (standalone) vs postMessage (integrated)
       ===================================================== */
    var GameStorage = {
      isInIframe: window.parent !== window,
      gameName: 'sliding_puzzle',

      loadProgress: function() {
        if (this.isInIframe) {
          // Integrated mode: request from parent
          window.parent.postMessage({
            type: 'requestGameProgress',
            game: this.gameName
          }, '*');
          return window.__gameProgress || { unlocked: 1, stars: {} };
        } else {
          // Standalone mode: use localStorage (original behavior)
          try {
            var data = localStorage.getItem('puzzle_progress');
            if (data) return JSON.parse(data);
          } catch (e) {}
          return { unlocked: 1, stars: {} };
        }
      },

      saveProgress: function(level, stars, moves, timeSeconds) {
        if (this.isInIframe) {
          // Integrated mode: send to parent for server sync
          window.parent.postMessage({
            type: 'saveGameProgress',
            game: this.gameName,
            level: level,
            stars: stars,
            moves: moves || 0,
            timeSeconds: timeSeconds || 0
          }, '*');
        } else {
          // Standalone mode: use localStorage
          try {
            var progress = this.loadProgress();
            progress.stars[level] = stars;
            if (level >= progress.unlocked) {
              progress.unlocked = level + 1;
            }
            localStorage.setItem('puzzle_progress', JSON.stringify(progress));
          } catch (e) {}
        }
      }
    };

    // Listen for progress data from parent (integrated mode only)
    if (GameStorage.isInIframe) {
      var lastProgressJson = null;
      window.addEventListener('message', function(event) {
        if (event.data.type === 'loadProgress') {
          var newProgressJson = JSON.stringify(event.data.progress);

          // Only update and re-render if progress actually changed
          if (newProgressJson !== lastProgressJson) {
            window.__gameProgress = event.data.progress;
            lastProgressJson = newProgressJson;

            if (typeof renderLevelSelect === 'function') {
              renderLevelSelect();
            }
          }
        }
      });

      // Notify parent that game is ready
      window.parent.postMessage({
        type: 'gameReady',
        game: GameStorage.gameName
      }, '*');
    }

    /* =====================================================
       LEVELS DATA
       Each level: { size, par, layout }
       layout is a flat array, 0 = empty space
       All layouts verified solvable.
       ===================================================== */
    var LEVELS = [
      // Level 1: 3x3, par 5
      { size: 3, par: 5, layout: [1,2,3, 4,0,5, 7,8,6] },
      // Level 2: 3x3, par 10
      { size: 3, par: 10, layout: [1,3,5, 4,2,6, 7,8,0] },
      // Level 3: 3x3, par 15
      { size: 3, par: 15, layout: [4,1,3, 7,2,5, 0,8,6] },
      // Level 4: 3x3, par 20
      { size: 3, par: 20, layout: [4,3,6, 8,0,1, 7,2,5] },
      // Level 5: 3x3, par 25
      { size: 3, par: 25, layout: [8,6,7, 2,5,4, 3,0,1] },
      // Level 6: 4x4, par 20
      { size: 4, par: 20, layout: [1,2,3,4, 5,6,7,8, 0,10,11,12, 9,13,14,15] },
      // Level 7: 4x4, par 35
      { size: 4, par: 35, layout: [5,1,3,4, 2,10,7,8, 9,6,11,12, 13,15,0,14] },
      // Level 8: 4x4, par 50
      { size: 4, par: 50, layout: [6,3,7,4, 5,1,11,8, 2,9,15,12, 13,10,14,0] },
      // Level 9: 5x5, par 60
      { size: 5, par: 60, layout: [1,2,3,4,5, 6,7,8,9,10, 11,12,0,15,14, 16,17,13,19,20, 21,22,23,18,24] }
    ];

    /* Tile color palette */
    var COLORS = [
      '#ff6b6b','#ff9f43','#feca57','#48dbfb','#0abde3',
      '#1dd1a1','#10ac84','#54a0ff','#5f27cd','#ee5a24',
      '#c44569','#574b90','#f78fb3','#3dc1d3','#e77f67',
      '#cf6a87','#786fa6','#f8a5c2','#63cdda','#ea8685',
      '#596275','#303952','#e15f41','#574b90','#78e08f'
    ];

    /* =====================================================
       STATE
       ===================================================== */
    var currentLevel = -1;
    var board = [];
    var moves = 0;
    var size = 3;
    var won = false;

    /* =====================================================
       STORAGE HELPERS
       ===================================================== */
    function loadProgress() {
      return GameStorage.loadProgress();
    }

    function saveProgress(prog) {
      var level = currentLevel + 1;
      var stars = prog.stars[level];
      GameStorage.saveProgress(level, stars, moves, 0);
    }

    /* =====================================================
       SOLVABILITY CHECK (inversion count)
       ===================================================== */
    function isSolvable(layout, sz) {
      var inv = 0;
      var arr = [];
      var blankRow = 0;
      for (var i = 0; i < layout.length; i++) {
        if (layout[i] === 0) {
          blankRow = Math.floor(i / sz);
          continue;
        }
        arr.push(layout[i]);
      }
      for (var a = 0; a < arr.length; a++) {
        for (var b = a + 1; b < arr.length; b++) {
          if (arr[a] > arr[b]) inv++;
        }
      }
      if (sz % 2 === 1) {
        return inv % 2 === 0;
      } else {
        return (inv + blankRow) % 2 === 0;
      }
    }

    /* =====================================================
       LEVEL SELECT RENDERING
       ===================================================== */
    function renderLevelSelect() {
      var prog = loadProgress();
      var grid = document.getElementById('levelGrid');
      grid.innerHTML = '';
      for (var i = 0; i < LEVELS.length; i++) {
        var btn = document.createElement('button');
        var unlocked = (i + 1) <= prog.unlocked;
        btn.className = 'level-btn ' + (unlocked ? 'unlocked' : 'locked');
        var label = '' + (i + 1);
        var starStr = '';
        if (unlocked && prog.stars[i + 1]) {
          var s = prog.stars[i + 1];
          for (var j = 0; j < 3; j++) {
            starStr += j < s ? '\u2605' : '\u2606';
          }
        }
        btn.innerHTML = label + (starStr ? '<span class="level-stars">' + starStr + '</span>' : '');
        if (unlocked) {
          btn.setAttribute('data-level', i);
          btn.addEventListener('click', onLevelTap);
          btn.addEventListener('touchend', onLevelTap, { passive: false });
        }
        grid.appendChild(btn);
      }
    }

    function onLevelTap(e) {
      e.preventDefault();
      var idx = parseInt(this.getAttribute('data-level'), 10);
      startLevel(idx);
    }

    /* =====================================================
       START LEVEL
       ===================================================== */
    function startLevel(idx) {
      currentLevel = idx;
      var lvl = LEVELS[idx];
      size = lvl.size;
      board = lvl.layout.slice();
      moves = 0;
      won = false;

      document.getElementById('levelSelect').style.display = 'none';
      var gameArea = document.getElementById('gameArea');
      gameArea.className = 'game-area active';

      document.getElementById('levelLabel').textContent = '关卡 ' + (idx + 1);
      document.getElementById('moveCount').textContent = '0';
      document.getElementById('parCount').textContent = '' + lvl.par;

      renderBoard();
    }

    /* =====================================================
       RENDER BOARD
       ===================================================== */
    function renderBoard() {
      var container = document.getElementById('boardContainer');
      container.innerHTML = '';

      var vw = Math.min(window.innerWidth - 32, 500);
      var gap = 6;
      var tileSize = Math.floor((vw - gap * (size + 1)) / size);
      if (tileSize < 60) tileSize = 60;
      var boardPx = tileSize * size + gap * (size + 1);
      container.style.width = boardPx + 'px';
      container.style.height = boardPx + 'px';

      for (var i = 0; i < board.length; i++) {
        if (board[i] === 0) continue;
        var val = board[i];
        var row = Math.floor(i / size);
        var col = i % size;

        var tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('data-val', val);
        tile.style.width = tileSize + 'px';
        tile.style.height = tileSize + 'px';
        tile.style.left = (gap + col * (tileSize + gap)) + 'px';
        tile.style.top = (gap + row * (tileSize + gap)) + 'px';
        tile.style.fontSize = (size <= 3 ? 2 : size <= 4 ? 1.6 : 1.3) + 'rem';
        tile.style.background = COLORS[(val - 1) % COLORS.length];
        tile.textContent = '' + val;

        tile.addEventListener('touchend', onTileTap, { passive: false });
        tile.addEventListener('click', onTileTap);
        container.appendChild(tile);
      }
    }

    /* Efficiently update tile positions without full re-render */
    function updateTilePositions() {
      var container = document.getElementById('boardContainer');
      var tiles = container.children;
      var vw = Math.min(window.innerWidth - 32, 500);
      var gap = 6;
      var tileSize = Math.floor((vw - gap * (size + 1)) / size);
      if (tileSize < 60) tileSize = 60;

      for (var t = 0; t < tiles.length; t++) {
        var val = parseInt(tiles[t].getAttribute('data-val'), 10);
        var idx = board.indexOf(val);
        var row = Math.floor(idx / size);
        var col = idx % size;
        tiles[t].style.left = (gap + col * (tileSize + gap)) + 'px';
        tiles[t].style.top = (gap + row * (tileSize + gap)) + 'px';
      }
    }

    /* =====================================================
       TILE TAP
       ===================================================== */
    function onTileTap(e) {
      e.preventDefault();
      if (won) return;
      var val = parseInt(this.getAttribute('data-val'), 10);
      var idx = board.indexOf(val);
      var emptyIdx = board.indexOf(0);

      var row = Math.floor(idx / size);
      var col = idx % size;
      var erow = Math.floor(emptyIdx / size);
      var ecol = emptyIdx % size;

      var adjacent = (Math.abs(row - erow) + Math.abs(col - ecol)) === 1;
      if (!adjacent) return;

      // Swap
      board[emptyIdx] = val;
      board[idx] = 0;
      moves++;
      document.getElementById('moveCount').textContent = '' + moves;

      updateTilePositions();

      // Check win
      if (checkWin()) {
        won = true;
        setTimeout(showWin, 350);
      }
    }

    /* =====================================================
       CHECK WIN
       ===================================================== */
    function checkWin() {
      for (var i = 0; i < board.length - 1; i++) {
        if (board[i] !== i + 1) return false;
      }
      return board[board.length - 1] === 0;
    }

    /* =====================================================
       SHOW WIN
       ===================================================== */
    function showWin() {
      var lvl = LEVELS[currentLevel];
      var stars = 1;
      if (moves <= lvl.par) stars = 3;
      else if (moves <= Math.floor(lvl.par * 1.5)) stars = 2;

      // Save progress
      var prog = loadProgress();
      var prev = prog.stars[currentLevel + 1] || 0;
      if (stars > prev) prog.stars[currentLevel + 1] = stars;
      if (currentLevel + 2 > prog.unlocked) {
        prog.unlocked = currentLevel + 2;
      }
      saveProgress(prog);

      // Show overlay
      var starStr = '';
      for (var i = 0; i < 3; i++) {
        starStr += i < stars ? '\u2b50' : '\u2606';
      }
      document.getElementById('winStars').textContent = starStr;
      document.getElementById('winMsg').textContent = '用了 ' + moves + ' 步完成（推荐 ' + lvl.par + ' 步）';

      var nextBtn = document.getElementById('winNextBtn');
      if (currentLevel + 1 >= LEVELS.length) {
        nextBtn.style.display = 'none';
      } else {
        nextBtn.style.display = '';
      }

      document.getElementById('winOverlay').className = 'overlay show';
    }

    /* =====================================================
       BUTTONS
       ===================================================== */
    document.getElementById('backBtn').addEventListener('click', function() {
      window.location.href = 'index.html';
    });

    document.getElementById('resetBtn').addEventListener('click', function() {
      if (currentLevel >= 0) startLevel(currentLevel);
    });

    document.getElementById('levelListBtn').addEventListener('click', function() {
      showLevelSelect();
    });

    document.getElementById('winBackBtn').addEventListener('click', function() {
      document.getElementById('winOverlay').className = 'overlay';
      showLevelSelect();
    });

    document.getElementById('winNextBtn').addEventListener('click', function() {
      document.getElementById('winOverlay').className = 'overlay';
      if (currentLevel + 1 < LEVELS.length) {
        startLevel(currentLevel + 1);
      }
    });

    function showLevelSelect() {
      document.getElementById('gameArea').className = 'game-area';
      document.getElementById('levelSelect').style.display = '';
      renderLevelSelect();
    }

    /* =====================================================
       INIT
       ===================================================== */
    // Ensure level 1 is always unlocked
    var initProg = loadProgress();
    if (initProg.unlocked < 1) {
      initProg.unlocked = 1;
      // Don't save progress during initialization - just ensure unlocked is set
      // saveProgress() expects currentLevel to be set, which it isn't during init
    }
    renderLevelSelect();

    // Handle resize
    window.addEventListener('resize', function() {
      if (currentLevel >= 0 && !won) {
        renderBoard();
      }
    });

    // Register SW
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(function() {});
    }
  </script>
</body>
</html>
